#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../utils/ast.h"
#include "../utils/log_utils.h"
#include "../../include/symbol_table.h"

/* Forward declarations for code generation functions */
static void generate_program(FILE* out, ast_node_t* node);
static void generate_type_declaration(FILE* out, ast_node_t* node);
static void generate_function_declaration(FILE* out, ast_node_t* node);
static void generate_function_prototype(FILE* out, ast_node_t* node);
static void generate_function_body(FILE* out, ast_node_t* node, symbol_scope_t* func_scope);
static void generate_prompt_block(FILE* out, ast_node_t* node, symbol_scope_t* func_scope);
static void generate_statement(FILE* out, ast_node_t* node, int indent);
static void generate_var_declaration(FILE* out, ast_node_t* node, int indent);
static void generate_expression_statement(FILE* out, ast_node_t* node, int indent);
static void generate_return_statement(FILE* out, ast_node_t* node, int indent);
static void generate_block(FILE* out, ast_node_t* node, int indent);
static void generate_expression(FILE* out, ast_node_t* node);
static void generate_call_expression(FILE* out, ast_node_t* node);
static void generate_class_declaration(FILE* out, ast_node_t* node);

// Add new forward declarations
static symbol_scope_t* analyze_function_scope(ast_node_t* func_node);
static void collect_variables_in_scope(symbol_scope_t* scope, char*** names, char*** types, int* count);
static void generate_template_substitution(FILE* out, ast_node_t* node, symbol_scope_t* func_scope, int indent);

/* Helper functions */
static const char* get_c_type_for_vibe_type(ast_node_t* type_node);
static void write_indentation(FILE* out, int indent);
static void generate_standard_headers(FILE* out);

/* Main code generation entry point */
int generate_code(ast_node_t* ast, const char* output_file) {
    if (!ast || !output_file) {
        ERROR("Invalid arguments to generate_code");
        return 0;
    }
    
    FILE* out = fopen(output_file, "w");
    if (!out) {
        ERROR("Failed to open output file: %s", output_file);
        return 0;
    }
    
    // Generate standard headers
    generate_standard_headers(out);
    
    // Generate code for the AST
    generate_program(out, ast);
    
    fclose(out);
    return 1;
}

/* Generate standard headers */
static void generate_standard_headers(FILE* out) {
    fprintf(out, "// Generated by VibeLang Compiler\n\n");
    fprintf(out, "#include <stdio.h>\n");
    fprintf(out, "#include <stdlib.h>\n");
    fprintf(out, "#include <string.h>\n");
    fprintf(out, "#include \"vibelang.h\"\n");
    fprintf(out, "#include \"vibelang/runtime.h\"\n\n");
    
    // Add runtime function declarations if they'll be used
    fprintf(out, "// Forward declarations for runtime functions\n");
    fprintf(out, "extern VibeValue* vibe_execute_prompt(const char* prompt);\n");
    fprintf(out, "extern char* format_prompt(const char* template, char** var_names, char** var_values, int var_count);\n\n");
}

/* Generate code for a program (top-level) */
static void generate_program(FILE* out, ast_node_t* node) {
    if (node->type != AST_PROGRAM) {
        ERROR("Expected AST_PROGRAM node");
        return;
    }
    
    // First pass: Generate all type definitions and function prototypes
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        
        if (child->type == AST_TYPE_DECL) {
            generate_type_declaration(out, child);
        } else if (child->type == AST_FUNCTION_DECL) {
            generate_function_prototype(out, child);
        } else if (child->type == AST_CLASS_DECL) {
            // Generate class prototypes (structs)
            // Will implement class declarations later
        }
    }
    
    fprintf(out, "\n");
    
    // Second pass: Generate all function implementations
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        
        if (child->type == AST_FUNCTION_DECL) {
            generate_function_declaration(out, child);
        } else if (child->type == AST_CLASS_DECL) {
            generate_class_declaration(out, child);
        }
    }
}

/* Generate code for a type declaration */
static void generate_type_declaration(FILE* out, ast_node_t* node) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    ast_node_t* type_node = node->children[0];
    if (!type_node) return;
    
    if (type_node->type == AST_MEANING_TYPE) {
        // For meaning types, typedef the base type
        if (type_node->child_count > 0) {
            ast_node_t* base_type = type_node->children[0];
            const char* c_type = get_c_type_for_vibe_type(base_type);
            
            fprintf(out, "// %s: %s\n", name, ast_get_string(type_node, "meaning"));
            fprintf(out, "typedef %s %s;\n\n", c_type, name);
        }
    } else if (type_node->type == AST_BASIC_TYPE) {
        // For basic types, just typedef
        const char* c_type = get_c_type_for_vibe_type(type_node);
        fprintf(out, "typedef %s %s;\n\n", c_type, name);
    }
}

/* Generate function prototype */
static void generate_function_prototype(FILE* out, ast_node_t* node) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    // Find return type
    ast_node_t* return_type = NULL;
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_BASIC_TYPE || 
            node->children[i]->type == AST_MEANING_TYPE) {
            return_type = node->children[i];
            break;
        }
    }
    
    // Default to void if no return type specified
    const char* return_type_str = "void";
    if (return_type) {
        return_type_str = get_c_type_for_vibe_type(return_type);
    }
    
    fprintf(out, "%s %s(", return_type_str, name);
    
    // Find parameter list
    ast_node_t* param_list = NULL;
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_PARAM_LIST) {
            param_list = node->children[i];
            break;
        }
    }
    
    // Generate parameter declarations
    if (param_list) {
        for (size_t i = 0; i < param_list->child_count; i++) {
            ast_node_t* param = param_list->children[i];
            const char* param_name = ast_get_string(param, "name");
            
            if (param->child_count > 0) {
                ast_node_t* param_type = param->children[0];
                const char* type_str = get_c_type_for_vibe_type(param_type);
                
                fprintf(out, "%s %s", type_str, param_name);
                
                if (i < param_list->child_count - 1) {
                    fprintf(out, ", ");
                }
            }
        }
    }
    
    fprintf(out, ");\n");
}

/* Generate function declaration */
static void generate_function_declaration(FILE* out, ast_node_t* node) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    // Find return type
    ast_node_t* return_type = NULL;
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_BASIC_TYPE || 
            node->children[i]->type == AST_MEANING_TYPE) {
            return_type = node->children[i];
            break;
        }
    }
    
    // Default to void if no return type specified
    const char* return_type_str = "void";
    if (return_type) {
        return_type_str = get_c_type_for_vibe_type(return_type);
    }
    
    fprintf(out, "%s %s(", return_type_str, name);
    
    // Find parameter list
    ast_node_t* param_list = NULL;
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_PARAM_LIST) {
            param_list = node->children[i];
            break;
        }
    }
    
    // Generate parameter declarations
    if (param_list) {
        for (size_t i = 0; i < param_list->child_count; i++) {
            ast_node_t* param = param_list->children[i];
            const char* param_name = ast_get_string(param, "name");
            
            if (param->child_count > 0) {
                ast_node_t* param_type = param->children[0];
                const char* type_str = get_c_type_for_vibe_type(param_type);
                
                fprintf(out, "%s %s", type_str, param_name);
                
                if (i < param_list->child_count - 1) {
                    fprintf(out, ", ");
                }
            }
        }
    }
    
    // Find function body and analyze scope to collect variables
    ast_node_t* body = NULL;
    symbol_scope_t* func_scope = analyze_function_scope(node);
    
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_FUNCTION_BODY) {
            body = node->children[i];
            break;
        }
    }
    
    fprintf(out, ") {\n");
    
    // Generate function body with scope information
    if (body) {
        generate_function_body(out, body, func_scope);
    }
    
    fprintf(out, "}\n\n");
    
    // Clean up scope
    if (func_scope) {
        free_symbol_scope(func_scope);
    }
}

/* Generate function body */
static void generate_function_body(FILE* out, ast_node_t* node, symbol_scope_t* func_scope) {
    ast_node_t* prompt_block = NULL;
    
    // Process statements and find prompt block (if any)
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        
        if (child->type == AST_PROMPT_BLOCK) {
            prompt_block = child;
        } else {
            generate_statement(out, child, 1);
        }
    }
    
    // If there's a prompt block, generate it last with variable substitution
    if (prompt_block) {
        generate_prompt_block(out, prompt_block, func_scope);
    }
}

/* Generate prompt block */
static void generate_prompt_block(FILE* out, ast_node_t* node, symbol_scope_t* func_scope) {
    const char* template = ast_get_string(node, "template");
    if (!template) return;
    
    // Generate code to execute the LLM prompt
    write_indentation(out, 1);
    fprintf(out, "// LLM Prompt: %s\n", template);
    
    write_indentation(out, 1);
    fprintf(out, "{\n");
    
    write_indentation(out, 2);
    fprintf(out, "VibeValue* prompt_result = NULL;\n");
    
    // Generate variable substitution code
    generate_template_substitution(out, node, func_scope, 2);
    
    write_indentation(out, 2);
    fprintf(out, "prompt_result = vibe_execute_prompt(formatted_prompt);\n");
    
    write_indentation(out, 2);
    fprintf(out, "if (prompt_result) {\n");
    
    // Add proper type conversion based on the function return type
    write_indentation(out, 3);
    fprintf(out, "// Convert LLM response to the appropriate return type\n");
    
    // Determine the type of the containing function
    ast_node_t* func_node = NULL;
    ast_node_t* parent = node;
    while (parent && parent->type != AST_FUNCTION_DECL) {
        // Look for function body parent
        for (size_t i = 0; i < node->child_count; i++) {
            if (parent->children[i]->type == AST_FUNCTION_BODY) {
                parent = parent->children[i];
                break;
            }
        }
    }
    
    if (parent && parent->type == AST_FUNCTION_DECL) {
        // Find return type of the function
        for (size_t i = 0; i < parent->child_count; i++) {
            if (parent->children[i]->type == AST_BASIC_TYPE || 
                parent->children[i]->type == AST_MEANING_TYPE) {
                // Generate appropriate conversion based on type
                const char* type_str = get_c_type_for_vibe_type(parent->children[i]);
                
                if (strcmp(type_str, "int") == 0) {
                    write_indentation(out, 3);
                    fprintf(out, "return vibe_value_get_int(prompt_result);\n");
                } else if (strcmp(type_str, "double") == 0) {
                    write_indentation(out, 3);
                    fprintf(out, "return vibe_value_get_float(prompt_result);\n");
                } else if (strcmp(type_str, "const char*") == 0) {
                    write_indentation(out, 3);
                    fprintf(out, "return vibe_value_get_string(prompt_result);\n");
                } else if (strcmp(type_str, "int") == 0 && strstr(type_str, "Bool")) {
                    write_indentation(out, 3);
                    fprintf(out, "return vibe_value_get_bool(prompt_result);\n");
                } else {
                    // Default case - just return the string value
                    write_indentation(out, 3);
                    fprintf(out, "return vibe_value_get_string(prompt_result);\n");
                }
                break;
            }
        }
    } else {
        // Default - just return the string value
        write_indentation(out, 3);
        fprintf(out, "return vibe_value_get_string(prompt_result);\n");
    }
    
    write_indentation(out, 2);
    fprintf(out, "}\n");
    
    write_indentation(out, 2);
    fprintf(out, "// Free resources\n");
    write_indentation(out, 2);
    fprintf(out, "free(formatted_prompt);\n");
    write_indentation(out, 2);
    fprintf(out, "for (int i = 0; i < var_count; i++) {\n");
    write_indentation(out, 3);
    fprintf(out, "free(var_values[i]);\n");
    write_indentation(out, 2);
    fprintf(out, "}\n");
    write_indentation(out, 2);
    fprintf(out, "free(var_names);\n");
    write_indentation(out, 2);
    fprintf(out, "free(var_values);\n");
    
    // Add a default return value based on function type
    write_indentation(out, 2);
    fprintf(out, "// Default return if prompt fails\n");
    write_indentation(out, 2);
    fprintf(out, "return NULL; // Should be replaced with appropriate default\n");
    
    write_indentation(out, 1);
    fprintf(out, "}\n");
}

/* Generate template variable substitution */
static void generate_template_substitution(FILE* out, ast_node_t* node, symbol_scope_t* func_scope, int indent) {
    const char* template = ast_get_string(node, "template");
    if (!template) return;
    
    // Collect variables in the scope
    char** var_names = NULL;
    char** var_types = NULL;
    int var_count = 0;
    
    collect_variables_in_scope(func_scope, &var_names, &var_types, &var_count);
    
    // Generate variable arrays
    write_indentation(out, indent);
    fprintf(out, "const char* prompt_template = \"%s\";\n", template);
    
    write_indentation(out, indent);
    fprintf(out, "int var_count = %d;\n", var_count);
    
    write_indentation(out, indent);
    fprintf(out, "char** var_names = malloc(sizeof(char*) * var_count);\n");
    
    write_indentation(out, indent);
    fprintf(out, "char** var_values = malloc(sizeof(char*) * var_count);\n");
    
    // Populate variable arrays
    for (int i = 0; i < var_count; i++) {
        write_indentation(out, indent);
        fprintf(out, "var_names[%d] = \"%s\";\n", i, var_names[i]);
        
        // Generate value conversion based on type
        write_indentation(out, indent);
        
        if (strstr(var_types[i], "int") || strstr(var_types[i], "Int")) {
            fprintf(out, "var_values[%d] = malloc(32); sprintf(var_values[%d], \"%%d\", %s);\n", 
                    i, i, var_names[i]);
        } else if (strstr(var_types[i], "float") || strstr(var_types[i], "Float") || 
                  strstr(var_types[i], "double")) {
            fprintf(out, "var_values[%d] = malloc(32); sprintf(var_values[%d], \"%%g\", %s);\n", 
                    i, i, var_names[i]);
        } else if (strstr(var_types[i], "bool") || strstr(var_types[i], "Bool")) {
            fprintf(out, "var_values[%d] = strdup(%s ? \"true\" : \"false\");\n", i, var_names[i]);
        } else if (strstr(var_types[i], "char") || strstr(var_types[i], "String")) {
            fprintf(out, "var_values[%d] = strdup(%s ? %s : \"\");\n", i, var_names[i], var_names[i]);
        } else {
            fprintf(out, "var_values[%d] = strdup(\"(unknown)\");\n", i);
        }
    }
    
    // Format the prompt template
    write_indentation(out, indent);
    fprintf(out, "char* formatted_prompt = format_prompt(prompt_template, var_names, var_values, var_count);\n");
    
    // Clean up
    if (var_names) free(var_names);
    if (var_types) free(var_types);
}

/* Analyze function and build scope with parameters and variables */
static symbol_scope_t* analyze_function_scope(ast_node_t* func_node) {
    if (!func_node) return NULL;
    
    symbol_scope_t* scope = create_symbol_scope(NULL, func_node);
    if (!scope) return NULL;
    
    // Add parameters to scope
    for (size_t i = 0; i < func_node->child_count; i++) {
        ast_node_t* child = func_node->children[i];
        
        if (child->type == AST_PARAM_LIST) {
            for (size_t j = 0; j < child->child_count; j++) {
                ast_node_t* param = child->children[j];
                const char* name = ast_get_string(param, "name");
                
                if (name && param->child_count > 0) {
                    ast_node_t* type_node = param->children[0];
                    symbol_add(scope, name, SYM_PARAMETER, param, type_node);
                }
            }
        } else if (child->type == AST_FUNCTION_BODY) {
            // Add local variables from function body
            for (size_t j = 0; j < child->child_count; j++) {
                ast_node_t* stmt = child->children[j];
                
                if (stmt->type == AST_VAR_DECL) {
                    const char* name = ast_get_string(stmt, "name");
                    
                    if (name) {
                        // Find variable type
                        ast_node_t* type_node = NULL;
                        for (size_t k = 0; k < stmt->child_count; k++) {
                            if (stmt->children[k]->type == AST_BASIC_TYPE || 
                                stmt->children[k]->type == AST_MEANING_TYPE) {
                                type_node = stmt->children[k];
                                break;
                            }
                        }
                        
                        symbol_add(scope, name, SYM_VAR, stmt, type_node);
                    }
                }
            }
        }
    }
    
    return scope;
}

/* Collect variables from scope into arrays */
static void collect_variables_in_scope(symbol_scope_t* scope, char*** names, char*** types, int* count) {
    if (!scope) return;
    
    // Count symbols
    int total = 0;
    symbol_t* sym = scope->symbols;
    while (sym) {
        if (sym->kind == SYM_PARAMETER || sym->kind == SYM_VAR) {
            total++;
        }
        sym = sym->next;
    }
    
    // Allocate arrays
    *names = malloc(sizeof(char*) * total);
    *types = malloc(sizeof(char*) * total);
    *count = total;
    
    // Fill arrays
    int i = 0;
    sym = scope->symbols;
    while (sym) {
        if (sym->kind == SYM_PARAMETER || sym->kind == SYM_VAR) {
            (*names)[i] = strdup(sym->name);
            
            if (sym->type_node) {
                (*types)[i] = strdup(get_c_type_for_vibe_type(sym->type_node));
            } else {
                (*types)[i] = strdup("unknown");
            }
            i++;
        }
        sym = sym->next;
    }
}

/* Generate statement */
static void generate_statement(FILE* out, ast_node_t* node, int indent) {
    if (!node) return;
    
    switch (node->type) {
        case AST_VAR_DECL:
            generate_var_declaration(out, node, indent);
            break;
        case AST_EXPR_STMT:
            generate_expression_statement(out, node, indent);
            break;
        case AST_RETURN_STMT:
            generate_return_statement(out, node, indent);
            break;
        case AST_BLOCK:
            generate_block(out, node, indent);
            break;
        default:
            WARNING("Unsupported statement type in code generation: %d", node->type);
            break;
    }
}

/* Generate variable declaration */
static void generate_var_declaration(FILE* out, ast_node_t* node, int indent) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    // Find type and init expression
    ast_node_t* type_node = NULL;
    ast_node_t* init_expr = NULL;
    
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        if (child->type == AST_BASIC_TYPE || child->type == AST_MEANING_TYPE) {
            type_node = child;
        } else {
            init_expr = child;
        }
    }
    
    // Determine C type
    const char* type_str = type_node ? get_c_type_for_vibe_type(type_node) : "auto";
    
    // Generate declaration
    write_indentation(out, indent);
    fprintf(out, "%s %s", type_str, name);
    
    // Generate initialization if present
    if (init_expr) {
        fprintf(out, " = ");
        generate_expression(out, init_expr);
    }
    
    fprintf(out, ";\n");
}

/* Generate expression statement */
static void generate_expression_statement(FILE* out, ast_node_t* node, int indent) {
    if (node->child_count == 0) return;
    
    write_indentation(out, indent);
    generate_expression(out, node->children[0]);
    fprintf(out, ";\n");
}

/* Generate return statement */
static void generate_return_statement(FILE* out, ast_node_t* node, int indent) {
    write_indentation(out, indent);
    fprintf(out, "return");
    
    if (node->child_count > 0) {
        fprintf(out, " ");
        generate_expression(out, node->children[0]);
    }
    
    fprintf(out, ";\n");
}

/* Generate block */
static void generate_block(FILE* out, ast_node_t* node, int indent) {
    write_indentation(out, indent);
    fprintf(out, "{\n");
    
    for (size_t i = 0; i < node->child_count; i++) {
        generate_statement(out, node->children[i], indent + 1);
    }
    
    write_indentation(out, indent);
    fprintf(out, "}\n");
}

/* Generate expression */
static void generate_expression(FILE* out, ast_node_t* node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_INT_LITERAL:
            fprintf(out, "%lld", ast_get_int(node, "value"));
            break;
        case AST_FLOAT_LITERAL:
            fprintf(out, "%g", ast_get_float(node, "value"));
            break;
        case AST_STRING_LITERAL:
            fprintf(out, "\"%s\"", ast_get_string(node, "value"));
            break;
        case AST_BOOL_LITERAL:
            fprintf(out, "%s", ast_get_bool(node, "value") ? "true" : "false");
            break;
        case AST_IDENTIFIER:
            fprintf(out, "%s", ast_get_string(node, "name"));
            break;
        case AST_CALL_EXPR:
            generate_call_expression(out, node);
            break;
        default:
            WARNING("Unsupported expression type in code generation: %d", node->type);
            break;
    }
}

/* Generate function call expression */
static void generate_call_expression(FILE* out, ast_node_t* node) {
    const char* func_name = ast_get_string(node, "function");
    if (!func_name) return;
    
    fprintf(out, "%s(", func_name);
    
    // Generate arguments
    for (size_t i = 0; i < node->child_count; i++) {
        generate_expression(out, node->children[i]);
        
        if (i < node->child_count - 1) {
            fprintf(out, ", ");
        }
    }
    
    fprintf(out, ")");
}

/* Generate class declaration */
static void generate_class_declaration(FILE* out, ast_node_t* node) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    // First, generate the struct definition
    fprintf(out, "typedef struct %s {\n", name);
    
    // Add member variables
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        if (child->type == AST_MEMBER_VAR) {
            const char* member_name = ast_get_string(child, "name");
            
            if (child->child_count > 0 && member_name) {
                ast_node_t* type_node = child->children[0];
                const char* type_str = get_c_type_for_vibe_type(type_node);
                
                fprintf(out, "    %s %s;\n", type_str, member_name);
            }
        }
    }
    
    fprintf(out, "} %s;\n\n", name);
    
    // Now generate methods
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        if (child->type == AST_FUNCTION_DECL) {
            // Generate method with self parameter
            generate_function_declaration(out, child);
        }
    }
}

/* Helper functions */

/* Map VibeLang types to C types */
static const char* get_c_type_for_vibe_type(ast_node_t* type_node) {
    if (!type_node) return "void";
    
    if (type_node->type == AST_BASIC_TYPE) {
        const char* type_name = ast_get_string(type_node, "type");
        if (!type_name) return "void";
        
        if (strcmp(type_name, "Int") == 0) {
            return "int";
        } else if (strcmp(type_name, "Float") == 0) {
            return "double";
        } else if (strcmp(type_name, "String") == 0) {
            return "const char*";
        } else if (strcmp(type_name, "Bool") == 0) {
            return "int";
        } else {
            // Assume custom type
            return type_name;
        }
    } else if (type_node->type == AST_MEANING_TYPE) {
        // For meaning types, use the underlying type
        if (type_node->child_count > 0) {
            return get_c_type_for_vibe_type(type_node->children[0]);
        }
    }
    
    return "void";
}

/* Write indentation to output */
static void write_indentation(FILE* out, int indent) {
    for (int i = 0; i < indent; i++) {
        fprintf(out, "    ");  // 4 spaces per indentation level
    }
}
