#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../utils/ast.h"
#include "../utils/log_utils.h"
#include "../../include/symbol_table.h"

/* Forward declarations for code generation functions */
static void generate_program(FILE* out, ast_node_t* node);
static void generate_type_declaration(FILE* out, ast_node_t* node);
static void generate_function_declaration(FILE* out, ast_node_t* node);
static void generate_function_prototype(FILE* out, ast_node_t* node);
static void generate_function_body(FILE* out, ast_node_t* node);
static void generate_prompt_block(FILE* out, ast_node_t* node);
static void generate_statement(FILE* out, ast_node_t* node, int indent);
static void generate_var_declaration(FILE* out, ast_node_t* node, int indent);
static void generate_expression_statement(FILE* out, ast_node_t* node, int indent);
static void generate_return_statement(FILE* out, ast_node_t* node, int indent);
static void generate_block(FILE* out, ast_node_t* node, int indent);
static void generate_expression(FILE* out, ast_node_t* node);
static void generate_call_expression(FILE* out, ast_node_t* node);
static void generate_class_declaration(FILE* out, ast_node_t* node);

/* Helper functions */
static const char* get_c_type_for_vibe_type(ast_node_t* type_node);
static void write_indentation(FILE* out, int indent);
static void generate_standard_headers(FILE* out);

/* Main code generation entry point */
int generate_code(ast_node_t* ast, const char* output_file) {
    if (!ast || !output_file) {
        ERROR("Invalid arguments to generate_code");
        return 0;
    }
    
    FILE* out = fopen(output_file, "w");
    if (!out) {
        ERROR("Failed to open output file: %s", output_file);
        return 0;
    }
    
    // Generate standard headers
    generate_standard_headers(out);
    
    // Generate code for the AST
    generate_program(out, ast);
    
    fclose(out);
    return 1;
}

/* Generate standard headers */
static void generate_standard_headers(FILE* out) {
    fprintf(out, "// Generated by VibeLang Compiler\n\n");
    fprintf(out, "#include <stdio.h>\n");
    fprintf(out, "#include <stdlib.h>\n");
    fprintf(out, "#include <string.h>\n");
    fprintf(out, "#include \"vibelang.h\"\n\n");
}

/* Generate code for a program (top-level) */
static void generate_program(FILE* out, ast_node_t* node) {
    if (node->type != AST_PROGRAM) {
        ERROR("Expected AST_PROGRAM node");
        return;
    }
    
    // First pass: Generate all type definitions and function prototypes
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        
        if (child->type == AST_TYPE_DECL) {
            generate_type_declaration(out, child);
        } else if (child->type == AST_FUNCTION_DECL) {
            generate_function_prototype(out, child);
        } else if (child->type == AST_CLASS_DECL) {
            // Generate class prototypes (structs)
            // Will implement class declarations later
        }
    }
    
    fprintf(out, "\n");
    
    // Second pass: Generate all function implementations
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        
        if (child->type == AST_FUNCTION_DECL) {
            generate_function_declaration(out, child);
        } else if (child->type == AST_CLASS_DECL) {
            generate_class_declaration(out, child);
        }
    }
}

/* Generate code for a type declaration */
static void generate_type_declaration(FILE* out, ast_node_t* node) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    ast_node_t* type_node = node->children[0];
    if (!type_node) return;
    
    if (type_node->type == AST_MEANING_TYPE) {
        // For meaning types, typedef the base type
        if (type_node->child_count > 0) {
            ast_node_t* base_type = type_node->children[0];
            const char* c_type = get_c_type_for_vibe_type(base_type);
            
            fprintf(out, "// %s: %s\n", name, ast_get_string(type_node, "meaning"));
            fprintf(out, "typedef %s %s;\n\n", c_type, name);
        }
    } else if (type_node->type == AST_BASIC_TYPE) {
        // For basic types, just typedef
        const char* c_type = get_c_type_for_vibe_type(type_node);
        fprintf(out, "typedef %s %s;\n\n", c_type, name);
    }
}

/* Generate function prototype */
static void generate_function_prototype(FILE* out, ast_node_t* node) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    // Find return type
    ast_node_t* return_type = NULL;
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_BASIC_TYPE || 
            node->children[i]->type == AST_MEANING_TYPE) {
            return_type = node->children[i];
            break;
        }
    }
    
    // Default to void if no return type specified
    const char* return_type_str = "void";
    if (return_type) {
        return_type_str = get_c_type_for_vibe_type(return_type);
    }
    
    fprintf(out, "%s %s(", return_type_str, name);
    
    // Find parameter list
    ast_node_t* param_list = NULL;
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_PARAM_LIST) {
            param_list = node->children[i];
            break;
        }
    }
    
    // Generate parameter declarations
    if (param_list) {
        for (size_t i = 0; i < param_list->child_count; i++) {
            ast_node_t* param = param_list->children[i];
            const char* param_name = ast_get_string(param, "name");
            
            if (param->child_count > 0) {
                ast_node_t* param_type = param->children[0];
                const char* type_str = get_c_type_for_vibe_type(param_type);
                
                fprintf(out, "%s %s", type_str, param_name);
                
                if (i < param_list->child_count - 1) {
                    fprintf(out, ", ");
                }
            }
        }
    }
    
    fprintf(out, ");\n");
}

/* Generate function declaration */
static void generate_function_declaration(FILE* out, ast_node_t* node) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    // Find return type
    ast_node_t* return_type = NULL;
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_BASIC_TYPE || 
            node->children[i]->type == AST_MEANING_TYPE) {
            return_type = node->children[i];
            break;
        }
    }
    
    // Default to void if no return type specified
    const char* return_type_str = "void";
    if (return_type) {
        return_type_str = get_c_type_for_vibe_type(return_type);
    }
    
    fprintf(out, "%s %s(", return_type_str, name);
    
    // Find parameter list
    ast_node_t* param_list = NULL;
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_PARAM_LIST) {
            param_list = node->children[i];
            break;
        }
    }
    
    // Generate parameter declarations
    if (param_list) {
        for (size_t i = 0; i < param_list->child_count; i++) {
            ast_node_t* param = param_list->children[i];
            const char* param_name = ast_get_string(param, "name");
            
            if (param->child_count > 0) {
                ast_node_t* param_type = param->children[0];
                const char* type_str = get_c_type_for_vibe_type(param_type);
                
                fprintf(out, "%s %s", type_str, param_name);
                
                if (i < param_list->child_count - 1) {
                    fprintf(out, ", ");
                }
            }
        }
    }
    
    fprintf(out, ") {\n");
    
    // Find function body
    for (size_t i = 0; i < node->child_count; i++) {
        if (node->children[i]->type == AST_FUNCTION_BODY) {
            generate_function_body(out, node->children[i]);
            break;
        }
    }
    
    fprintf(out, "}\n\n");
}

/* Generate function body */
static void generate_function_body(FILE* out, ast_node_t* node) {
    ast_node_t* prompt_block = NULL;
    
    // Process statements and find prompt block (if any)
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        
        if (child->type == AST_PROMPT_BLOCK) {
            prompt_block = child;
        } else {
            generate_statement(out, child, 1);
        }
    }
    
    // If there's a prompt block, generate it last
    if (prompt_block) {
        generate_prompt_block(out, prompt_block);
    }
}

/* Generate prompt block */
static void generate_prompt_block(FILE* out, ast_node_t* node) {
    const char* template = ast_get_string(node, "template");
    if (!template) return;
    
    // Generate code to execute the LLM prompt
    write_indentation(out, 1);
    fprintf(out, "// LLM Prompt: %s\n", template);
    
    write_indentation(out, 1);
    fprintf(out, "{\n");
    
    write_indentation(out, 2);
    fprintf(out, "VibeValue* prompt_result = NULL;\n");
    
    write_indentation(out, 2);
    fprintf(out, "const char* prompt_template = \"%s\";\n", template);
    
    write_indentation(out, 2);
    fprintf(out, "// TODO: Replace placeholders in prompt template with variable values\n");
    
    write_indentation(out, 2);
    fprintf(out, "prompt_result = vibe_execute_prompt(prompt_template);\n");
    
    write_indentation(out, 2);
    fprintf(out, "if (prompt_result) {\n");
    
    write_indentation(out, 3);
    fprintf(out, "// TODO: Convert LLM response to appropriate return type\n");
    
    write_indentation(out, 3);
    fprintf(out, "return vibe_value_get_as_native(prompt_result);\n");
    
    write_indentation(out, 2);
    fprintf(out, "}\n");
    
    write_indentation(out, 1);
    fprintf(out, "}\n");
}

/* Generate statement */
static void generate_statement(FILE* out, ast_node_t* node, int indent) {
    if (!node) return;
    
    switch (node->type) {
        case AST_VAR_DECL:
            generate_var_declaration(out, node, indent);
            break;
        case AST_EXPR_STMT:
            generate_expression_statement(out, node, indent);
            break;
        case AST_RETURN_STMT:
            generate_return_statement(out, node, indent);
            break;
        case AST_BLOCK:
            generate_block(out, node, indent);
            break;
        default:
            WARNING("Unsupported statement type in code generation: %d", node->type);
            break;
    }
}

/* Generate variable declaration */
static void generate_var_declaration(FILE* out, ast_node_t* node, int indent) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    // Find type and init expression
    ast_node_t* type_node = NULL;
    ast_node_t* init_expr = NULL;
    
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        if (child->type == AST_BASIC_TYPE || child->type == AST_MEANING_TYPE) {
            type_node = child;
        } else {
            init_expr = child;
        }
    }
    
    // Determine C type
    const char* type_str = type_node ? get_c_type_for_vibe_type(type_node) : "auto";
    
    // Generate declaration
    write_indentation(out, indent);
    fprintf(out, "%s %s", type_str, name);
    
    // Generate initialization if present
    if (init_expr) {
        fprintf(out, " = ");
        generate_expression(out, init_expr);
    }
    
    fprintf(out, ";\n");
}

/* Generate expression statement */
static void generate_expression_statement(FILE* out, ast_node_t* node, int indent) {
    if (node->child_count == 0) return;
    
    write_indentation(out, indent);
    generate_expression(out, node->children[0]);
    fprintf(out, ";\n");
}

/* Generate return statement */
static void generate_return_statement(FILE* out, ast_node_t* node, int indent) {
    write_indentation(out, indent);
    fprintf(out, "return");
    
    if (node->child_count > 0) {
        fprintf(out, " ");
        generate_expression(out, node->children[0]);
    }
    
    fprintf(out, ";\n");
}

/* Generate block */
static void generate_block(FILE* out, ast_node_t* node, int indent) {
    write_indentation(out, indent);
    fprintf(out, "{\n");
    
    for (size_t i = 0; i < node->child_count; i++) {
        generate_statement(out, node->children[i], indent + 1);
    }
    
    write_indentation(out, indent);
    fprintf(out, "}\n");
}

/* Generate expression */
static void generate_expression(FILE* out, ast_node_t* node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_INT_LITERAL:
            fprintf(out, "%lld", ast_get_int(node, "value"));
            break;
        case AST_FLOAT_LITERAL:
            fprintf(out, "%g", ast_get_float(node, "value"));
            break;
        case AST_STRING_LITERAL:
            fprintf(out, "\"%s\"", ast_get_string(node, "value"));
            break;
        case AST_BOOL_LITERAL:
            fprintf(out, "%s", ast_get_bool(node, "value") ? "true" : "false");
            break;
        case AST_IDENTIFIER:
            fprintf(out, "%s", ast_get_string(node, "name"));
            break;
        case AST_CALL_EXPR:
            generate_call_expression(out, node);
            break;
        default:
            WARNING("Unsupported expression type in code generation: %d", node->type);
            break;
    }
}

/* Generate function call expression */
static void generate_call_expression(FILE* out, ast_node_t* node) {
    const char* func_name = ast_get_string(node, "function");
    if (!func_name) return;
    
    fprintf(out, "%s(", func_name);
    
    // Generate arguments
    for (size_t i = 0; i < node->child_count; i++) {
        generate_expression(out, node->children[i]);
        
        if (i < node->child_count - 1) {
            fprintf(out, ", ");
        }
    }
    
    fprintf(out, ")");
}

/* Generate class declaration */
static void generate_class_declaration(FILE* out, ast_node_t* node) {
    const char* name = ast_get_string(node, "name");
    if (!name) return;
    
    // First, generate the struct definition
    fprintf(out, "typedef struct %s {\n", name);
    
    // Add member variables
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        if (child->type == AST_MEMBER_VAR) {
            const char* member_name = ast_get_string(child, "name");
            
            if (child->child_count > 0 && member_name) {
                ast_node_t* type_node = child->children[0];
                const char* type_str = get_c_type_for_vibe_type(type_node);
                
                fprintf(out, "    %s %s;\n", type_str, member_name);
            }
        }
    }
    
    fprintf(out, "} %s;\n\n", name);
    
    // Now generate methods
    for (size_t i = 0; i < node->child_count; i++) {
        ast_node_t* child = node->children[i];
        if (child->type == AST_FUNCTION_DECL) {
            // Generate method with self parameter
            generate_function_declaration(out, child);
        }
    }
}

/* Helper functions */

/* Map VibeLang types to C types */
static const char* get_c_type_for_vibe_type(ast_node_t* type_node) {
    if (!type_node) return "void";
    
    if (type_node->type == AST_BASIC_TYPE) {
        const char* type_name = ast_get_string(type_node, "type");
        if (!type_name) return "void";
        
        if (strcmp(type_name, "Int") == 0) {
            return "int";
        } else if (strcmp(type_name, "Float") == 0) {
            return "double";
        } else if (strcmp(type_name, "String") == 0) {
            return "const char*";
        } else if (strcmp(type_name, "Bool") == 0) {
            return "int";
        } else {
            // Assume custom type
            return type_name;
        }
    } else if (type_node->type == AST_MEANING_TYPE) {
        // For meaning types, use the underlying type
        if (type_node->child_count > 0) {
            return get_c_type_for_vibe_type(type_node->children[0]);
        }
    }
    
    return "void";
}

/* Write indentation to output */
static void write_indentation(FILE* out, int indent) {
    for (int i = 0; i < indent; i++) {
        fprintf(out, "    ");  // 4 spaces per indentation level
    }
}
